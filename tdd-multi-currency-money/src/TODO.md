- [x] $5 + 10CHF = $10（レートが2:1の場合）
- [x] $5 + $5 = $10
- [ ] $5 + $5がMoneyを返す
- [x] Bank.reduce(Money)
- [x] Moneyを変換して換算する
- [x] Reduce(Bank, String)
- [x] Sum.plus
- [x] Expression.times
- [ ] 異なる通貨同士の足し算どうする？
- [ ] Moneyの丸め処理をどうする？
- [ ] hashCode
- [ ] nullとの比較
- [ ] 他のオブジェクトとの等価性比較

## TDDのステップ
- テストを書く
- コンパイラを通す
- テストを走らせ、失敗を確認する
- テストを通す
- 重複を排除する

## メモ
### 13章 実装を導くテスト
testPlusReturnsSumを追加した。書籍では振る舞いのテストじゃなく内部実装に深く関係したテストのため長生きはしないが、このテストが通ればゴールに近づくため利用したと書かれている。
内部実装に深く関係しているかはさておき、実装を前に進めるテストなのは間違いない。

逆説的に長生きさせるのは振る舞いに関するテストといっている。ここでいう振る舞いに関するテストってなんだろう？テスト対象クラスの振る舞いに関するテストってことかな？内部実装との違いをいまいち言語化できてない。
- 振る舞いのテスト：入力に対する出力を確認すること
- 内部実装に依存したテスト：内部のメソッドが1回呼ばれること、テスト対象と同じクラスのメソッドをモック化することなど。

### 14章
実装前にテストを書くと、そのクラスに追加すべき振る舞いがわかる（このとき、既存設計を修正するアイディアが出ることがあり、これが設計へのフィードバックと言うことなんだと思う）。
振る舞いに対して想定する動作をテストとして書き、それを満たすように実装する。最後に内部品質を高めるためにリファクタリングする。

必ずしも実装を追加する際にテストを書かなきゃいけないわけじゃない。例えば、TDDのリファクタリングフェーズで新たなクラスを実装している段階でテストを追加する必要はない。振る舞いをテストするためのテストはあるので。ただし、そのクラスのテストが必要だと感じたら書けば良い。

テストは実装の挙動を把握するためにも利用できる。ArrayがHashMapのキーに使えるかなど。